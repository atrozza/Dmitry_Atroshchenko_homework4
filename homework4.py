#Dmitry Atroshchenko
#07.11.2023
#Description: Homework 4
#My vetsion Python 3.11



#теперь тесты написаны с использованием библиотеки pytest
#нам нужно ее установить: pip install pytest
#и запустить как обычный файл: pytest test_Homework4.py



#Выведите n-ое число Фибоначчи, используя только временные переменные, циклические операторы и условные операторы. n - вводится.
def fibonacci(n):
    # Если значение 'n' меньше или равно 0, то функция вернет значение 'None'.
    if n <= 0:
        return None
    # Если 'n' равно 1, то функция вернет 0, так как первое число Фибоначчи равно 0.
    elif n == 1:
        return 0
    # Если 'n' равно 2, то функция вернет 1, так как второе число Фибоначчи равно 1.
    elif n == 2:
        return 1
    # Если 'n' больше 2, то выполнится следующий код.
    else:
        # Инициализируем переменную 'a' с нулевым значением, которая представляет первое число Фибоначчи.
        a = 0
        # Инициализируем переменную 'b' с единичным значением, которая представляет второе число Фибоначчи.
        b = 1
        # Создаем цикл, который будет выполняться от 2 до 'n - 1'.
        for i in range(2, n):
            # Вычисляем сумму 'a' и 'b' и сохраняем ее в переменной 'c'.
            c = a + b
            # Обновляем 'a', присваивая ей значение на 'b'.
            a = b
            # Обновляем 'b', присваивая ей значение на 'c'.
            b = c
        # После завершения цикла функция вернет значение 'b', которое представляет 'n'-ное число Фибоначчи.
        return b
# Все верно, отличное решение, много комментариев.


#Определите, является ли число палиндромом (читается слева направо и справа налево одинаково). Число положительное целое, произвольной длины. Задача требует работать только с числами (без конвертации числа в строку или что-нибудь еще).
def palindrome(n):
    # Верная проверка
    #Условие что отрицательные числа не могут быть палиндромами
    if n < 0:
        return False

    # Сохраняем исходное значение 'n' в переменной 'original_n' для сравнения.
    original_n = n
    # Инициализируем переменную 'reversed_n' с нулевым значением, в которой будем хранить перевернутое число 'n'.
    reversed_n = 0

    # Начинаем цикл, который будет выполняться до тех пор, пока 'n' больше 0.
    while n > 0:
        # Находим последнюю цифру 'n' путем взятия остатка от деления на 10.
        digit = n % 10
        # Увеличиваем 'reversed_n', умножая его на 10 и добавляя найденную цифру 'digit'.
        reversed_n = reversed_n * 10 + digit
        # Уменьшаем 'n', убирая последнюю цифру путем целочисленного деления на 10.
        n //= 10

    # После завершения цикла сравниваем исходное значение 'n' с его перевернутой версией 'reversed_n'.
    # Если они равны, то функция вернет 'True', иначе - 'False'.
    return original_n == reversed_n
# Хорошее решение, для альтернативного см ответы


#Напишите генератор, который возвращает цифры от S до N, но вместо чисел, кратных 3 пишет Fizz, вместо чисел кратный 5 пишет Buzz, а вместо чисел одновременно кратных и 3 и 5 - FizzBuzz.
def fizz_buzz(S, N):
    # Определение шага 'step' для цикла, который будет равен 1, если 'S' меньше 'N', иначе -1.
    step = 1 if S < N else -1
    # Создаем цикл, который перебирает значения от 'S' до 'N' с учетом шага 'step'.
    # Шаг нужен для случая если нужно перебирать элеметы не от мешьшего к большему а на оборот от большего к меньшему значению
    for i in range(S, N + step, step):
        # Инициализируем переменную 'output' как пустую строку, в которой будем формировать результат.
        output = ""
        # Если 'i' делится нацело на 3, то добавляем "Fizz" к 'output'.
        if i % 3 == 0:
            output += "Fizz"
        # Если 'i' делится нацело на 5, то добавляем "Buzz" к 'output'.
        if i % 5 == 0:
            output += "Buzz"
        # Если 'output' все еще пустой, то присваиваем ему строковое представление 'i'.
        if not output:
            output = str(i)
        # Возвращаем текущее значение 'output' как результат итерации цикла с использованием генератора (yield).
        yield output
        # Абсолютно верно
